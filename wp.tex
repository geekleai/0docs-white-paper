% \documentclass[12pt,oneside]{article}
\documentclass[12pt,twocolumn]{article}

\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage[bottom]{footmisc}
\usepackage{bookmark}
\usepackage{microtype}
\usepackage{amsmath}
\usepackage{multicol}
\usepackage{mdframed}
\usepackage{setspace}
\usepackage{pgfplots}
\usepackage{graphicx}
\usepackage{fancyvrb}

\usepackage{geometry}
\geometry{
  a4paper,         % Paper size
  total={7.5in,10in}, % Width and height of the text area
  left=0.75in,     % Left margin
  right=0.75in,    % Right margin
  top=1in,         % Top margin
  bottom=1in       % Bottom margin
}

% \usepackage[absolute]{textpos}\TPGrid{16}{16}
\usepackage{tikz}
  \usetikzlibrary{shapes}
  \usetikzlibrary{arrows.meta,arrows,shadows,trees,fit,calc,positioning,decorations.pathmorphing}
\usepackage{xcolor}
  \definecolor{mypink}{HTML}{560CCE}
  \definecolor{myblack}{HTML}{232527}
\usepackage{hyperref}
  \hypersetup{colorlinks=true,allcolors=blue!40!black}

\setlength{\topskip}{6pt}
\setlength{\parindent}{0pt} 
\setlength{\parskip}{6pt}
\setlength{\columnsep}{1cm} % Space between columns

\date{\small\today}
\title{%
  Code Explainability Agents \\
  \colorbox{mypink}{\small\sffamily\color{white}{White Paper}}}

\usepackage[style=authoryear,sorting=nyt,backend=biber,
  hyperref=true,abbreviate=true,
  maxcitenames=1,maxbibnames=1]{biblatex}

\renewbibmacro{in:}{}
\addbibresource{books.bib}

\author{Bohdan Snisar}

\begin{document}
\raggedbottom
\maketitle

\begin{abstract}
  \textbf{Modern software complexity challenges the shared understanding between business and technical teams. 
  This whitepaper introduces code explainability agents—intelligent systems that translate evolving codebases 
  into clear, context-rich narratives. By linking source code details to strategic objectives, these agents 
  enhance communication, reduce cognitive overhead, and improve maintainability.}
  \end{abstract}


\section{Introduction}

In the modern software development landscape, applications are becoming increasingly complex, driven by the demand
for more features, scalability, and integration with various technologies. The advent of microservices, cloud computing, 
and the Internet of Things (IoT) has led to codebases that are not only large but also highly interconnected. Developers are 
tasked with understanding and maintaining systems that may consist of millions of lines of code spread across numerous repositories 
and services.

\subsection{Complexity of the SDLC and Developer Time Allocation}

The SDLC extends beyond coding to encompass requirements analysis, design, testing, deployment, integration, and maintenance. 
These activities, supported by numerous tools—issue trackers, review platforms, and CI systems—fragment developers’ workflows. 
As they continually switch contexts, forming a coherent understanding of the product’s evolving state proves difficult.

Contrary to common belief, developers spend most of their time understanding existing code rather than writing new code. 
Studies indicate that up to 70\% of this effort involves comprehension \textcite{ko2006exploratory}. Even simple queries often 
require navigating multiple files \textcite{Schroer_2024}, and internal research at Microsoft corroborates that writing new code 
is a minor portion of a developer’s day \textcite{meyer2021today}.

This emphasis on code comprehension, combined with a fragmented SDLC, increases cognitive load. High-level business 
objectives rarely map cleanly onto technical structures, complicating communication and alignment.

Improved visualization and tooling, as suggested by Storey \textcite{meyer2021today}, can alleviate these burdens. 
Reducing the cognitive overhead of code comprehension and facilitating access to pertinent information enhances 
developer productivity, shortens time-to-market, and better aligns technical outputs with strategic goals.

\subsection{Divergent Representations: Business vs. Technical}

Business teams prioritize product-market fit, deadlines, and ROI, expressing these aims through roadmaps, marketing plans,
and user stories. 
Developers work with technical details—code, architecture diagrams, and logs. Though both refer to the same product, their 
conceptual languages rarely align.

This disconnect complicates communication. Business teams struggle to map objectives to specific technical components,
while developers may lose sight of overarching goals. 
In the absence of a unifying framework, bridging these perspectives is difficult.

\subsection{The Impact of AI-Generated Code}

AI-assisted code generation accelerates development but often increases code churn and technical debt. Quick fixes, 
code duplication, and weak documentation reduce maintainability and clarity. 
GitClear \textcite{gitclear2024} projects rising churn rates, suggesting that AI-generated contributions often mimic 
transient developers.

As code evolves haphazardly, aligning it with strategic objectives becomes increasingly challenging. This complexity 
demands solutions that render code comprehensible and transparent, 
even as it mutates at machine speed.

\section{The Need for AI Agents}

An AI-driven agent dedicated to translating code-level details into accessible, business-oriented documentation can bridge 
gap between business and tech and improve SDLC capabilities overall.

\begin{itemize}
  \item \textbf{Live:} 
  By providing real-time, context-rich narratives that bridge technical and business perspectives, these AI-driven agents 
foster a shared understanding of complex software systems. 

  \item \textbf{Context:} 
  Rather than forcing developers to repeatedly re-contextualize and interpret code, or leaving business stakeholders struggling to connect strategic goals with the technical infrastructure, 
this mediator reduces cognitive load and streamlines communication. 

  \item \textbf{Focuse:} 
- Developers can concentrate on innovation without being bogged down in manual documentation, while business teams gain clarity into the product’s technical foundations, 
enhancing decision-making and ensuring alignment with strategic objectives. 

  \item \textbf{Communication:} 
  Acting as mediators, these agents simplify collaboration, ensuring all stakeholders are aligned and communication flows seamlessly.
\end{itemize}

In essence, these agents ground strategic intentions in concrete technical realities, unifying the entire organization around a common understanding of what the 
software does and why it matters.


\section{AI In Code Explainability}

This chapter introduces a systematic code explainability methodology that leverages 
the hierarchical structure of software systems. By representing code as a graph of 
interconnected entities and analyzing relationships at multiple scales, it generates coherent, 
context-aware summaries. The approach combines parsing, graph clustering, and large language models (LLMs) 
to deliver meaningful explanations that align technical and business perspectives.


\subsection{Multi-Scale Method}
Codebases are inherently layered, with functions and classes forming modules, packages, and services. 
Traditional explainability tools often treat these layers in isolation, failing to capture how local decisions 
impact global architecture.

A multi-scale approach leverages this hierarchy by systematically assembling summaries 
from the smallest elements into higher-level narratives. This maintains fidelity to the 
code while articulating its structure and purpose in increasingly abstract terms.

The resulting output is accurate and strategically useful, enabling stakeholders to
understand technical trade-offs and developers to see how their work contributes to broader objectives.



\printbibliography%
\end{document}