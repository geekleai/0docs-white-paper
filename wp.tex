\documentclass[12pt,oneside]{article}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage[bottom]{footmisc}
\usepackage{bookmark}
\usepackage{microtype}
\usepackage{amsmath}
\usepackage{multicol}
\usepackage{mdframed}
\usepackage{setspace}
\usepackage{pgfplots}
\usepackage{graphicx}
\usepackage{fancyvrb}
\usepackage[absolute]{textpos}\TPGrid{16}{16}
\usepackage{tikz}
  \usetikzlibrary{shapes}
  \usetikzlibrary{arrows.meta}
  \usetikzlibrary{arrows}
  \usetikzlibrary{shadows}
  \usetikzlibrary{trees}
  \usetikzlibrary{fit}
  \usetikzlibrary{calc}
  \usetikzlibrary{positioning}
  \usetikzlibrary{decorations.pathmorphing}
\usepackage{./tikz-uml}
\usepackage{everypage}
  \AddEverypageHook{
    \begin{textblock}{0.5}[0,0](0,0)
      \tikz \node[fill=mypink,minimum width=0.5\TPHorizModule,minimum height=16\TPVertModule] {};
    \end{textblock}
    \begin{textblock}{0.125}[0,0](0.5,0)
      \tikz \node[fill=myblack,inner sep=0, minimum width=0.125\TPHorizModule,minimum height=16\TPVertModule] {};
    \end{textblock}
  }
\usepackage{xcolor}
  \definecolor{firebrick}{HTML}{B22222}
  \definecolor{myred}{HTML}{CF0A2C}
  \definecolor{mypink}{HTML}{560CCE}
  \definecolor{myblack}{HTML}{232527}
\newcommand\dd[1]{\colorbox{gray!30}{\texttt{#1}}}
\usepackage{hyperref}
  \hypersetup{colorlinks=true,allcolors=blue!40!black}
\setlength{\topskip}{6pt}
\setlength{\parindent}{0pt} % indent first line
\setlength{\parskip}{6pt} % before par
\date{\small\today}
\title{%
  Agent To Code Language \\
  \colorbox{mypink}{\small\sffamily\color{white}{White Paper}}}
% \usepackage[style=authoryear,sorting=nyt,backend=biber,
%   hyperref=true,abbreviate=true,
%   maxcitenames=1,maxbibnames=1]{biblatex}

  \usepackage{biblatex}  
\renewbibmacro{in:}{}
\addbibresource{books.bib}

\tikzset{node distance=1.6cm, auto, every text node part/.style={align=center, font={\sffamily\small}}}
\tikzstyle{block} = [draw=myblack, fill=white, inner sep=0.3cm, outer sep=0.1cm, thick]
\tikzstyle{ln} = [draw, ->, very thick, arrows={-triangle 90}, every text node part/.append style={font={\sffamily\scriptsize}}]
\author{Bohdan Snisar} % Add authors here
\begin{document}
\raggedbottom

\maketitle
\begin{abstract}
  As software systems grow in complexity, navigating large codebases has become an increasingly critical task for 
  developers and automated tools. Traditional navigation methods often fall short in enabling efficient exploration 
  and comprehension of code without direct human involvement. To address this challenge, we propose 
  the Agent Code Language Interface (ACLI)—a specialized framework designed for 
  language model (LM) agents to interact with codebases effectively. By leveraging the 
  Language Server Protocol (LSP) and adhering to agent-friendly design principles, ACLI facilitates seamless 
  navigation, comprehension, and documentation generation without requiring code modification.

  ACLI introduces features like an interactive File Viewer for structured code navigation and robust 
  Context Management to streamline agent interactions. These tools provide simple, efficient, and informative 
  actions for locating and understanding code elements while maintaining concise and relevant context. This framework 
  transforms code navigation into a structured, agent-accessible process, empowering LMs to act as intelligent assistants for 
  developers, researchers, and organizations aiming to enhance their understanding of complex software systems.
\end{abstract}

% \onehalfspace

\section{Introduction}

\subsection{The Growing Complexity of Codebases}

In the modern software development landscape, applications are becoming increasingly complex, driven by the demand
for more features, scalability, and integration with various technologies. The advent of microservices, cloud computing, 
and the Internet of Things (IoT) has led to codebases that are not only large but also highly interconnected. Developers are 
tasked with understanding and maintaining systems that may consist of millions of lines of code spread across numerous repositories 
and services.

This complexity poses significant challenges in code comprehension, maintenance, and onboarding of new team members. Developers must 
navigate through layers of abstractions, understand legacy code, and grasp intricate dependencies between modules. The cognitive load 
associated with these tasks can impede productivity and increase the likelihood of introducing errors during development.

\subsection{Time Spent on Code Navigation vs. Writing}

Contrary to the common perception that software development primarily involves writing new code, numerous studies have
demonstrated that developers spend a substantial portion of their time navigating and understanding existing codebases.
According to research by \citep{ko2006exploratory}, developers can spend up to 70\% of their time comprehending code
when performing maintenance tasks. Similarly, \citep{Schroer_2024} found that answering even simple questions
about code often requires exploring multiple files and understanding the relationships between various code components.

At Microsoft, internal studies (\citep{meyer2021today}) have indicated that writing new code constitutes a relatively small 
fraction of a developer’s workflow. The majority of time is devoted to reading existing code,
debugging, and comprehending how different parts of the system interact. This allocation of time 
highlights the importance of efficient code navigation tools and methodologies to enhance developer
productivity and reduce time-to-market for software products.


\subsection{Limitations of Current Tools}

While Integrated Development Environments (IDEs) and code editors have evolved to include 
features like syntax highlighting, code completion, and basic navigation capabilities, these 
tools often fall short in addressing the challenges posed by large and complex codebases. Traditional
navigation tools are designed with direct human interaction in mind, relying on graphical interfaces and manual input.
They may not scale effectively when developers need to comprehend extensive codebases with deeply nested dependencies.

Moreover, existing tools typically provide limited support for building a holistic understanding of the code structure.
Features like “Go to Definition” or “Find References” are useful but require manual effort and do not offer insights 
into higher-level code organization, design patterns, or the rationale behind certain implementations. This gap necessitates 
a more advanced approach to code navigation that can assist developers in constructing mental models of the codebase efficiently.

Additionally, these tools are not optimized for interaction with automated agents or language models that could aid in code
comprehension and documentation generation. As artificial intelligence (AI) and machine learning technologies mature, there 
is a growing opportunity to leverage intelligent agents to assist developers. However, the lack of suitable interfaces and 
protocols limits the integration of such agents into the development workflow.

\printbibliography%
\end{document}
